#!/usr/bin/env node

import * as fs from 'fs';
import * as path from 'path';
import { compile } from 'json-schema-to-typescript';
import { get, sortBy } from 'lodash';
import { Module } from 'module';

/**
 * Takes in raw JavaScript code and returns a compiled module of it
 *
 * @param code - JavaScript code to compile
 * @param filename - filename to use for the module
 * @returns compiled module
 */
const requireFromString = (code: string, filename: string = '') => {
	const parent = require.main || undefined;
	const m = new Module(filename, parent);
	m.filename = filename;

	// @ts-expect-error - We have to reference the private _nodeModulePaths here
	const paths: string[] = Module._nodeModulePaths(path.dirname(filename));
	m.paths = paths;

	// @ts-expect-error - We have to reference the private _compile here
	m._compile(code, filename);

	return m.exports;
};

/**
 * Generates TypeScript interface definition files for any type contracts in the given list of contracts.
 * The generated files will be written to files under 'lib/types/contracts', which will be deleted and re-created
 * as part of this function's actions.
 *
 * @param input - path to the built contracts directory
 * @param output - path to the output directory
 * @returns list of boolean values indicating success
 */
export async function generateContractInterfaces(
	input: string,
	output: string,
): Promise<void> {
	console.log('Generating TS interface from JSON schema...');

	// Prepare banner comment for generated files
	const packageJson = JSON.parse(
		fs.readFileSync(path.resolve(process.cwd(), 'package.json'), 'utf8'),
	);
	const bannerComment = `/*
 * This file was automatically generated by 'npm run types'.
 *
 * DO NOT MODIFY IT BY HAND!
 */

`;

	const baseContractImports = `
// tslint:disable: array-type

import type { Contract, ContractDefinition } from '${
		packageJson && packageJson.name === 'autumndb' ? '../' : 'autumndb'
	}';

`;

	// Compile TypeScript and read in contract definitions
	const inputFile = path.join(input, 'index.js');
	const inputPath = path.resolve(process.cwd(), inputFile);
	const code = fs.readFileSync(inputPath, {
		encoding: 'utf8',
	});
	const initialCwd = process.cwd();
	process.chdir(path.dirname(inputPath));
	const contracts = requireFromString(code, path.basename(inputPath)).contracts;
	process.chdir(initialCwd);

	// Create output path if it doesn't already exist
	const outputDir = path.resolve(process.cwd(), output);
	if (!fs.existsSync(outputDir)) {
		fs.mkdirSync(outputDir, {
			recursive: true,
		});
	}

	// Delete previous output data
	await fs.promises.rm(outputDir, {
		recursive: true,
	});
	fs.mkdirSync(outputDir);

	// Add contract export to index file
	const indexFile = path.resolve(outputDir, 'index.ts');
	await fs.promises.appendFile(indexFile, bannerComment);

	// Compile and output type contract interface definitions
	const typeContracts = sortBy(contracts, 'slug').filter((contract) => {
		return contract.type.split('@')[0] === 'type';
	});
	for (const contract of typeContracts) {
		const schema = get(contract, ['data', 'schema', 'properties', 'data'], {});
		schema.title = `${contract.slug}-data`;

		let compiled = await compile(schema, contract.slug, {
			ignoreMinAndMaxItems: true,
			style: {
				bracketSpacing: true,
				printWidth: 120,
				semi: true,
				singleQuote: true,
				tabWidth: 2,
				trailingComma: 'all',
				useTabs: true,
			},
			bannerComment: '',
		});
		const contractName = compiled.match(/interface ([a-zA-Z]+)Data/)![1];

		// Add definitions for the contract and contract definition
		compiled += `
export interface ${contractName}ContractDefinition
extends ContractDefinition<${contractName}Data> {}

export interface ${contractName}Contract
extends Contract<${contractName}Data> {}

`;
		// Output to contract definition file
		const contractFile = path.resolve(outputDir, `${contract.slug}.ts`);
		await fs.promises.writeFile(
			contractFile,
			bannerComment + baseContractImports + compiled,
		);

		// Add contract export to index file
		await fs.promises.appendFile(
			indexFile,
			`export type { ${contractName}Contract, ${contractName}ContractDefinition, ${contractName}Data } from './${contract.slug}';\n`,
		);
	}
}
